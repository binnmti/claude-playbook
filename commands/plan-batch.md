---
description: 複数プランを依存関係を考慮して一括実行する（オーケストレーション）
---

# 複数プラン一括実行（オーケストレーション）

複数のプランフォルダを指定し、依存関係を自動解析しながら自走式で順次実行します。

## 核心原則

1. **自走式**: 成功している限り確認なしで全プランを完遂
2. **コンテキスト分離**: 各プランを独立したサブエージェントで実行
3. **依存関係自動解析**: プランのREADME.mdから依存関係を判断
4. **積み上げブランチ**: 親ブランチに全プランの成果を積み上げ

## 使い方

```
/plan-batch doc/plans/plan-a doc/plans/plan-b doc/plans/plan-c
```

引数: スペース区切りでプランフォルダを指定

### 依存関係の明示（オプション）

明示的に依存を指定したい場合は `->` を使用：

```
/plan-batch doc/plans/plan-a -> doc/plans/plan-b doc/plans/plan-c
```

明示指定がない場合は、**自動的に依存関係を解析**する。

## 実行手順

### Step 1: プラン解析と依存関係の自動検出

1. **全プランのREADME.mdを読み込み**
   - 各プランのブランチ名、タスク一覧、概要を把握

2. **依存関係の自動解析**（`Task` ツール Explore で実行）

   以下の観点で依存関係を判断：

   | 判断基準 | 例 |
   |---------|---|
   | **機能的依存** | plan-bがplan-aで作成するAPIを使う |
   | **ファイル依存** | plan-bがplan-aで変更するファイルを前提とする |
   | **概念的依存** | plan-bの説明に「plan-aの後」「〜を前提に」等の記述 |
   | **暗黙的依存** | 基盤機能 → 応用機能の順序が自然 |

   **プロンプト例**:
   ```
   以下のプランのREADME.mdを分析し、依存関係を判断してください。

   ## プラン一覧
   {各プランのREADME.md内容}

   ## 判断基準
   - 機能的依存: あるプランが別のプランで作成する機能を使う
   - ファイル依存: 同じファイルを変更する場合、順序が重要
   - 概念的依存: 説明文から読み取れる前提条件
   - 独立: 他のプランと関係なく実行可能

   ## 出力形式
   JSON形式で依存関係を出力:
   {
     "dependencies": [
       {"plan": "plan-b", "depends_on": "plan-a", "reason": "plan-aで作成するXxxServiceを使用"},
       {"plan": "plan-c", "depends_on": null, "reason": "独立した機能"}
     ],
     "execution_order": ["plan-a", "plan-c", "plan-b"]
   }
   ```

3. **依存関係が明示指定されている場合**
   - 明示指定を優先
   - 自動解析結果は参考情報として表示

4. **実行計画を生成・表示**

```markdown
## オーケストレーション計画

### 依存関係（自動解析結果）
- plan-a: 独立（基盤機能）
- plan-b: plan-a に依存（plan-aで作成するXxxServiceを使用）
- plan-c: 独立（別機能）

### 実行順序
| # | プラン | 依存先 | ステータス |
|---|--------|--------|-----------|
| 1 | plan-a | なし | pending |
| 2 | plan-c | なし | pending |
| 3 | plan-b | plan-a | pending |

この計画で実行を開始します。
```

5. **親ブランチを作成**

```bash
# 現在のブランチをベースに親ブランチを作成
git checkout -b batch/{YYYY-MM-DD}-{説明}
```

親ブランチ名の例: `batch/2026-01-31-multi-feature-rollout`

### Step 2: 各プランの実行（サブエージェント）

各プランを `Task` ツール（general-purpose）で実行：

```
以下のプランを /plan-run として実行してください。

## プランフォルダ
{プランフォルダパス}

## 重要な指示
1. .claude/commands/plan-run.md の手順に従って実行
2. ただし、ブランチは既に作成済みなので、ブランチ切り替え/作成はスキップ
3. 全タスクを完了し、ファイナルレビューまで実行
4. **ダッシュボード（index.html）の更新はスキップ**（後でまとめて更新）
5. 完了後、プランフォルダをdoneに移動してコミット

## 報告形式
- ステータス: completed / failed / blocked
- 完了タスク: N / M
- 最終コミット: {hash}
- エラー内容: （失敗時のみ）
```

**コンテキスト管理**: サブエージェントが独立したコンテキストで動作するため、親のコンテキストは圧迫されない。

### Step 3: プラン完了後の処理

**成功時**:
1. 実行計画テーブルのステータスを `completed` に更新
2. 次のプランへ進む

**失敗時**:
1. ステータスを `failed` に更新
2. **依存先プランをすべて `skipped` に更新**
   - 例: plan-a 失敗 → plan-b を skipped
3. **独立したプランは続行**
   - 例: plan-c は続行

### Step 4: 次のプランへ（ループ）

実行順序に従って Step 2-3 を繰り返す。

**スキップ判定**:
- ステータスが `skipped` のプランは実行しない
- 依存先が `failed` または `skipped` なら自動的に `skipped`

### Step 5: 全プラン完了後の最終処理

1. **最終統合テスト**

```bash
dotnet build
dotnet test
```

2. **ダッシュボードHTML一括更新**

   `doc/plans/index.html` を編集：

   - 完了した各プランを「進行中」から「完了済み」セクションに移動
   - 進捗バーを100%に更新
   - バッジの数を更新（進行中 -N、完了 +N）
   - 失敗/スキップしたプランはそのまま「進行中」に残す
   - 最終更新日を更新

3. **変更をコミット**

```bash
git add doc/plans/index.html
git commit -m "chore: update dashboard after batch execution"
```

4. **実行結果サマリー**

```markdown
## オーケストレーション完了

### 実行結果
| # | プラン | ステータス | 完了タスク |
|---|--------|-----------|-----------|
| 1 | plan-a | completed | 3/3 |
| 2 | plan-c | completed | 2/2 |
| 3 | plan-b | failed | 1/2 |

### 統計
- 成功: 2 プラン
- 失敗: 1 プラン
- スキップ: 0 プラン

### ブランチ情報
- 親ブランチ: batch/2026-01-31-multi-feature-rollout
- 全変更を確認: `git log main..HEAD`
- 差分を確認: `git diff main`

### 次のステップ
- 全成功: PRを作成してレビュー
- 部分失敗: 失敗プランを修正後、個別に `/plan-run` で再実行
```

## 出力形式

**実行中:**
```
## プラン 1/5 実行中: plan-a
[サブエージェントに委譲]
```

**プラン完了時:**
```
## プラン 1/5 完了: plan-a → 次: plan-c
```

**失敗時:**
```
## プラン 3/5 失敗: plan-b
依存先スキップ: なし
独立プラン続行: plan-d
```

**全完了時:**
```
## オーケストレーション完了

成功: 4 / 5 プラン
失敗: 1 プラン (plan-b)
スキップ: 0 プラン

親ブランチ: batch/2026-01-31-multi-feature-rollout
ダッシュボード更新済み
```

## エラーハンドリング

| 状況 | 対応 |
|------|------|
| プランが失敗 | 依存先をスキップ、独立プランは続行 |
| 依存先がスキップ済み | 自動的にスキップ |
| ビルドエラー | 当該プランを失敗扱い |
| コンテキスト超過 | サブエージェント使用で自動回避 |
| 全プラン失敗 | 最初の失敗原因を報告 |

## ブランチ戦略

```
main
  └── batch/2026-01-31-multi-feature-rollout (親ブランチ)
        ├── plan-a のコミット群
        ├── plan-c のコミット群
        └── plan-b のコミット群（失敗時は部分コミットのみ）
```

**利点**:
- 全変更を1つのブランチで確認可能
- PRを1つで全機能をレビュー可能
- 部分失敗しても成功分は保持

## 注意事項

- 各プランは plan-new で作成済みであること
- 依存関係は自動解析されるが、明示指定（`->`）があれば優先
- サブエージェントがコンテキストを分離するため、長時間実行可能
- 失敗したプランは後で個別に `/plan-run` で再実行可能
- **自走式のため、実行開始後は完了まで介入不要**
- **ダッシュボード更新は全プラン完了後にまとめて実行**

## 引数なしの場合

```
/plan-batch
```

1. `doc/plans/` 内の全プランフォルダを検出（done除く）
2. 全プランのREADME.mdを読み込み
3. **依存関係を自動解析**して実行順序を決定
4. 実行計画を表示して開始

## 部分再実行

一部のプランだけ再実行したい場合:

```
/plan-batch doc/plans/plan-c doc/plans/plan-d
```

既存の親ブランチがあれば、そのブランチ上で続行。
